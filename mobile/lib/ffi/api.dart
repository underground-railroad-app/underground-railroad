// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `to_string_err`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BASE_DATA_DIR`, `DATABASE`, `DATA_DIR`, `IDENTITY`, `VEILID_CLIENT`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `deref`, `deref`, `deref`, `deref`, `deref`, `fmt`, `fmt`, `fmt`, `fmt`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`

/// Initialize the Underground Railroad with user credentials
Future<String> initialize({required String name, required String password, required String baseDataDir}) =>
    RustLib.instance.api.crateApiInitialize(name: name, password: password, baseDataDir: baseDataDir);

/// Create an emergency request
Future<String> createEmergency(
        {required List<String> needs, required String region, required String urgency, required int numPeople}) =>
    RustLib.instance.api.crateApiCreateEmergency(needs: needs, region: region, urgency: urgency, numPeople: numPeople);

/// Get network status
Future<NetworkStatus> getStatus() => RustLib.instance.api.crateApiGetStatus();

/// Register a safe house
Future<String> registerSafeHouse({required String name, required String region, required int capacity}) =>
    RustLib.instance.api.crateApiRegisterSafeHouse(name: name, region: region, capacity: capacity);

/// Add a contact with their Veilid mailbox key
Future<void> addContact({required String name, required String fingerprintWords, required String mailboxKey}) =>
    RustLib.instance.api.crateApiAddContact(name: name, fingerprintWords: fingerprintWords, mailboxKey: mailboxKey);

/// Get a contact's Veilid mailbox key
Future<String?> getContactMailboxKey({required String contactId}) =>
    RustLib.instance.api.crateApiGetContactMailboxKey(contactId: contactId);

/// Get all contacts
Future<List<ContactInfo>> getContacts() => RustLib.instance.api.crateApiGetContacts();

/// Send an encrypted message to a contact
Future<String> sendMessage({required String contactId, required String content}) =>
    RustLib.instance.api.crateApiSendMessage(contactId: contactId, content: content);

/// Save a received message from Veilid to the database
/// Called by Flutter after polling Veilid mailbox
Future<String> saveReceivedMessage(
        {required String senderId, required String content, required PlatformInt64 createdAt}) =>
    RustLib.instance.api.crateApiSaveReceivedMessage(senderId: senderId, content: content, createdAt: createdAt);

/// Get serialized message data for sending via Veilid
Future<Uint8List> getMessageForVeilid({required String contactId, required String messageId}) =>
    RustLib.instance.api.crateApiGetMessageForVeilid(contactId: contactId, messageId: messageId);

/// Decrypt and save a received message from Veilid
Future<String> decryptAndSaveMessage({required List<int> encryptedData}) =>
    RustLib.instance.api.crateApiDecryptAndSaveMessage(encryptedData: encryptedData);

/// Get messages from a conversation with a contact
Future<List<MessageInfo>> getMessages({required String contactId, required int limit}) =>
    RustLib.instance.api.crateApiGetMessages(contactId: contactId, limit: limit);

/// Get list of all conversations
Future<List<ConversationInfo>> getConversations() => RustLib.instance.api.crateApiGetConversations();

/// Mark a message as read
Future<void> markMessageRead({required String messageId}) =>
    RustLib.instance.api.crateApiMarkMessageRead(messageId: messageId);

/// Get Veilid mailbox key for current identity
Future<String?> getMailboxKey() => RustLib.instance.api.crateApiGetMailboxKey();

/// Set Veilid mailbox key for current identity
Future<void> setMailboxKey({required String mailboxKey}) =>
    RustLib.instance.api.crateApiSetMailboxKey(mailboxKey: mailboxKey);

/// Create a Veilid mailbox using the desktop Veilid client
Future<String> createVeilidMailboxDesktop() => RustLib.instance.api.crateApiCreateVeilidMailboxDesktop();

/// Send message via desktop Veilid client
Future<bool> sendMessageViaVeilidDesktop({required String recipientMailboxKey, required List<int> messageData}) =>
    RustLib.instance.api
        .crateApiSendMessageViaVeilidDesktop(recipientMailboxKey: recipientMailboxKey, messageData: messageData);

/// Poll mailbox for new messages (desktop)
Future<List<Uint8List>> pollVeilidMailboxDesktop({required String mailboxKey}) =>
    RustLib.instance.api.crateApiPollVeilidMailboxDesktop(mailboxKey: mailboxKey);

/// Shutdown Veilid and cleanup
Future<void> shutdown() => RustLib.instance.api.crateApiShutdown();

/// Contact information
class ContactInfo {
  final String id;
  final String name;
  final String fingerprint;

  const ContactInfo({
    required this.id,
    required this.name,
    required this.fingerprint,
  });

  @override
  int get hashCode => id.hashCode ^ name.hashCode ^ fingerprint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          fingerprint == other.fingerprint;
}

/// Conversation summary for Flutter
class ConversationInfo {
  final String contactId;
  final String contactName;
  final int messageCount;
  final int unreadCount;
  final String? lastMessage;
  final PlatformInt64? lastMessageTime;

  const ConversationInfo({
    required this.contactId,
    required this.contactName,
    required this.messageCount,
    required this.unreadCount,
    this.lastMessage,
    this.lastMessageTime,
  });

  @override
  int get hashCode =>
      contactId.hashCode ^
      contactName.hashCode ^
      messageCount.hashCode ^
      unreadCount.hashCode ^
      lastMessage.hashCode ^
      lastMessageTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationInfo &&
          runtimeType == other.runtimeType &&
          contactId == other.contactId &&
          contactName == other.contactName &&
          messageCount == other.messageCount &&
          unreadCount == other.unreadCount &&
          lastMessage == other.lastMessage &&
          lastMessageTime == other.lastMessageTime;
}

/// Message information for Flutter
class MessageInfo {
  final String id;
  final String senderId;
  final String recipientId;
  final String content;
  final String status;
  final String direction;
  final PlatformInt64 createdAt;
  final bool isRead;

  const MessageInfo({
    required this.id,
    required this.senderId,
    required this.recipientId,
    required this.content,
    required this.status,
    required this.direction,
    required this.createdAt,
    required this.isRead,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      senderId.hashCode ^
      recipientId.hashCode ^
      content.hashCode ^
      status.hashCode ^
      direction.hashCode ^
      createdAt.hashCode ^
      isRead.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          senderId == other.senderId &&
          recipientId == other.recipientId &&
          content == other.content &&
          status == other.status &&
          direction == other.direction &&
          createdAt == other.createdAt &&
          isRead == other.isRead;
}

/// Network status info
class NetworkStatus {
  final bool veilidConnected;
  final int contactsCount;
  final int emergenciesCount;
  final int safeHousesCount;

  const NetworkStatus({
    required this.veilidConnected,
    required this.contactsCount,
    required this.emergenciesCount,
    required this.safeHousesCount,
  });

  @override
  int get hashCode =>
      veilidConnected.hashCode ^ contactsCount.hashCode ^ emergenciesCount.hashCode ^ safeHousesCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkStatus &&
          runtimeType == other.runtimeType &&
          veilidConnected == other.veilidConnected &&
          contactsCount == other.contactsCount &&
          emergenciesCount == other.emergenciesCount &&
          safeHousesCount == other.safeHousesCount;
}
